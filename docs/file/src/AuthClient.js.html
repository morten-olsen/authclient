<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/AuthClient.js | Authenticatornator</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="this is awesome library"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="Authenticatornator"><meta property="twitter:description" content="this is awesome library"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  <a href="test.html" data-ice="testLink">Test</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/morten-olsen/authclient"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/AuthClient.js~AuthClient.html">AuthClient</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Crypto.js~Crypto.html">Crypto</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Store.js~Store.html">Store</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Options">Options</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-ResponseTypes">ResponseTypes</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-TokenResponse">TokenResponse</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-TokenTypes">TokenTypes</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/AuthClient.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import axios from &apos;axios&apos;;
import Crypto from &apos;./Crypto&apos;;
import Store from &apos;./Store&apos;;

const defaultOptions = {
  store: new Store(&apos;auth_&apos;),
  tokenType: &apos;authorization_code&apos;,
  crypto: new Crypto(),
};

/**
  @typedef {Object} TokenTypes
  @property {string} baseUrl
  @property {string} clientId
*/

/**
  @typedef {Object} ResponseTypes
  @property {string} baseUrl
  @property {string} clientId
*/

/**
  @typedef {Object} Options
  @property {string} baseUrl
  @property {string} clientId
  @property {string} [clientSecret]
  @property {string} redirectUri
  @property {ResponseTypes[]} responseTypes
  @property {string[]} scopes
  @property {Store} [store]
  @property {TokenTypes} [tokenType]
  @property {Crypto} [crypto]
  @property {string} [username]
  @property {string} [password]
  @property {string} [refreshToken]
  @property {string[]} [acrs]
*/

/**
  @typedef {Object} TokenResponse
*/

/**
 * Client
 *
 * @example
 * const authClient = new AuthClient({
 *   baseUrl: &apos;https://your-open-id-server.com&apos;,
 *   clientId: &apos;your_client_id&apos;,
 *   redirectUri: &apos;https://your-site.com&apos;,
 *   responseTypes: [&apos;id_token&apos;, &apos;token&apos;],
 *   scopes: [
 *     &apos;openid&apos;,
 *     &apos;profile&apos;,
 *   ],
 * });
 *
 * const url = await authClient.getLoginUrl();
 * window.location.href = url;
 */
class AuthClient {
  /**
   *
   * @param {Options} options
   */
  constructor(options) {
    /** @ignore */
    this._options = {
      ...defaultOptions,
      ...options,
    };
  }

  /** @ignore */
  async _getConfiguration(options) {
    const { baseUrl } = options;
    const url = `${baseUrl}/.well-known/openid-configuration`;
    const response = await axios.get(url);
    return response.data;
  }

  /** @ignore */
  async _getKeys(options) {
    const { baseUrl } = options;
    const url = `${baseUrl}/.well-known/openid-configuration/jwks`;
    const response = await axios.get(url);
    return response.data;
  }

  /** @ignore */
  async _createVerifier(options) {
    const { crypto } = options;
    const verifier = crypto.random();
    const challengeBytes = await crypto.sha256(verifier);
    const challenge = await crypto.bytesToBase64(challengeBytes);
    return {
      verifier,
      challenge,
    };
  }

  /** @ignore */
  async _createRequestUrl(options, { authorization_endpoint: authorizationEndpoint }) {
    const { store, crypto } = this._options;
    /* eslint-disable camelcase */
    const {
      clientId: client_id,
      redirectUri: redirect_uri,
      scopes = [],
      responseTypes = [&apos;code&apos;],
      extra = {},
      pkce: pkceEnabled,
    } = options;

    const state = crypto.random();
    let pkce;
    if (crypto &amp;&amp; pkceEnabled) {
      pkce = await this._createVerifier(options);
    }

    const params = {
      client_id,
      redirect_uri,
      scope: scopes ? scopes.join(&apos; &apos;) : undefined,
      code_challenge: pkce ? pkce.challenge : undefined,
      code_challenge_method: pkce ? &apos;S256&apos; : undefined,
      response_type: responseTypes.join(&apos; &apos;),
      state,
      nonce: responseTypes.includes(&apos;id_token&apos;) ? crypto.random() : undefined,
      ...extra,
    };
    /* eslint-enable camelcase */

    await store.setItem(state, {
      ...params,
      ...pkce,
    });

    const parts = Object.keys(params).filter(key =&gt; params[key]).map(key =&gt; `${key}=${encodeURIComponent(params[key])}`);
    return `${authorizationEndpoint}?${parts.join(&apos;&amp;&apos;)}`;
  }

  /** @ignore */
  _parseUrl(url) {
    const [, query] = url.split(url.indexOf(&apos;#&apos;) &gt;= 0 ? &apos;#&apos; : &apos;?&apos;);
    if (!query) {
      return {};
    }
    return query.split(&apos;&amp;&apos;).reduce((output, current) =&gt; {
      const [name, value] = current.split(&apos;=&apos;);
      return {
        ...output,
        [name]: decodeURIComponent(value),
      };
    }, {});
  }

  /** @ignore */
  async _requestToken(options, config) {
    const {
      clientId,
      tokenType,
      refreshToken,
      store,
      code,
      sessionId,
      clientSecret,
      redirectUri,
      username,
      password,
      // acrs,
      // scopes,
    } = options;

    const session = await store.getItem(sessionId);
    const response = await axios.post(config.token_endpoint, {
      client_id: clientId,
      client_secret: clientSecret,
      redirect_uri: redirectUri,
      grant_type: tokenType,
      username,
      password,
      code,
      // scope: scopes ? scopes.join(&apos; &apos;) : undefined,
      // acr_values: acrs,
      refresh_token: refreshToken,
      code_verifier: session ? session.verifier : undefined,
    });
    if (sessionId) {
      store.removeItem(sessionId);
    }
    return response.data;
  }

  /**
   * A method to test id a given url contains the information
   * needed to extract or generate a token
   * @param {string} url The url containing the server informations
   * @returns {bool} indicates it the url is valid
   */
  async isValidUrl(url) {
    const params = await this._parseUrl(url);
    return !!params.access_token || !!params.code;
  }

  /**
   * Generate a login url which the application should show to the user
   * @param {Options} options the options combined which will be combined
   *                          with the client&apos;s global options
   * @returns {string} The resulting url which should be shown to the user
   * @example
   * const url = await authClient.getLoginUrl();
   * location.href = url;
   */
  async getLoginUrl(options) {
    const extendedOptions = {
      ...this._options,
      options,
    };
    const config = await this._getConfiguration(extendedOptions);
    const request = await this._createRequestUrl(extendedOptions, config);
    return request;
  }

  /**
   * Transform a redirect url into a valid token
   * @param {string} url The url containing the server informations
   * @param {Options} options the options combined which will be combined
   *                          with the client&apos;s global options
   * @returns {TokenResponse} The resulting token
   * @example
   * if (window.location.hash) {
   *   const token = await authClient.exchangeToken(window.location.href);
   * }
   */
  async exchangeToken(url, options) {
    const extendedOptions = {
      ...this._options,
      options,
    };
    const {
      store,
    } = extendedOptions;
    const codeResponse = await this._parseUrl(url);

    if (codeResponse.access_token) {
      store.removeItem(codeResponse.session_state);
      return codeResponse;
    } else if (codeResponse.code) {
      const config = await this._getConfiguration(extendedOptions);
      const response = await this._requestToken({
        code: codeResponse.code,
        sessionId: codeResponse.state,
        ...extendedOptions,
      }, config);

      return response;
    }
    return undefined;
  }

  /**
   * Generates a new token, either using the refreshToken or the username
   * and password supplied to options
   * @param {Options} options the options combined which will be combined
   *                          with the client&apos;s global options
   * @returns {TokenResponse} The resulting token
   * @example
   * const token = await authClient.getToken({
   *   username: &apos;admin&apos;,
   *   password: &apos;god&apos;,
   * });
   */
  async getToken(options) {
    const extendedOptions = {
      ...this._options,
      options,
    };
    const config = await this._getConfiguration(extendedOptions);
    const response = await this._requestToken(extendedOptions, config);

    console.log(response);
    return response;
  }
}

export default AuthClient;
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.0.4)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
